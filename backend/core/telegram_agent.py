import asyncio
import os
import time
from typing import List, Dict, Optional
from datetime import datetime

from telethon import TelegramClient, events
from telethon.tl.types import Message, User, Chat, Channel
from sqlalchemy.orm import Session

from database.models.base import SessionLocal
from database.models.campaign import Campaign
from database.models.log import ActivityLog

# –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ AI –∫–ª–∏–µ–Ω—Ç—ã (–∑–∞–º–µ–Ω—è—é—Ç utils.*)
class SimpleClaudeClient:
    """–ü—Ä–æ—Å—Ç–æ–π Claude –∫–ª–∏–µ–Ω—Ç"""
    def __init__(self):
        try:
            import anthropic
            self.api_key = os.getenv("ANTHROPIC_API_KEY")
            if self.api_key:
                self.client = anthropic.Anthropic(api_key=self.api_key)
                print("Claude –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            else:
                self.client = None
        except ImportError:
            self.client = None
            
    async def generate_response(self, prompt: str, **kwargs) -> str:
        if not self.client:
            return "Claude –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω - –ø—Ä–æ–≤–µ—Ä—å—Ç–µ ANTHROPIC_API_KEY –∏ —É—Å—Ç–∞–Ω–æ–≤–∫—É anthropic"
        try:
            import asyncio
            response = await asyncio.to_thread(
                self.client.messages.create,
                model="claude-3-sonnet-20240229",
                max_tokens=1000,
                messages=[{"role": "user", "content": prompt}]
            )
            return response.content[0].text
        except Exception as e:
            return f"–û—à–∏–±–∫–∞ Claude: {e}"

class SimpleOpenAIClient:
    """–ü—Ä–æ—Å—Ç–æ–π OpenAI –∫–ª–∏–µ–Ω—Ç"""
    def __init__(self):
        try:
            import openai
            self.api_key = os.getenv("OPENAI_API_KEY")
            if self.api_key:
                self.client = openai.OpenAI(api_key=self.api_key)
                print("OpenAI –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            else:
                self.client = None
        except ImportError:
            self.client = None
            
    async def generate_response(self, prompt: str, **kwargs) -> str:
        if not self.client:
            return "OpenAI –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω - –ø—Ä–æ–≤–µ—Ä—å—Ç–µ OPENAI_API_KEY –∏ —É—Å—Ç–∞–Ω–æ–≤–∫—É openai"
        try:
            import asyncio
            response = await asyncio.to_thread(
                self.client.chat.completions.create,
                model="gpt-4",
                max_tokens=1000,
                messages=[{"role": "user", "content": prompt}]
            )
            return response.choices[0].message.content
        except Exception as e:
            return f"–û—à–∏–±–∫–∞ OpenAI: {e}"

# –ê–ª–∏–∞—Å—ã –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
ClaudeClient = SimpleClaudeClient
OpenAIClient = SimpleOpenAIClient
ZepMemoryManager = None  # –ó–∞–≥–ª—É—à–∫–∞


class TelegramAgent:
    """
    –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å Telegram-–∞–≥–µ–Ω—Ç–∞ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —á–∞—Ç–æ–≤ –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤
    """
    
    def __init__(self):
        self.api_id = int(os.getenv("TELEGRAM_API_ID"))
        self.api_hash = os.getenv("TELEGRAM_API_HASH")
        self.phone = os.getenv("TELEGRAM_PHONE")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–æ–≤
        self.client = TelegramClient("telegram_agent", self.api_id, self.api_hash)
        
        # AI –∫–ª–∏–µ–Ω—Ç—ã - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
        try:
            self.claude_client = ClaudeClient()
            print("‚úÖ Claude Client –¥–æ—Å—Ç—É–ø–µ–Ω")
        except Exception as e:
            print(f"‚ö†Ô∏è Claude Client –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
            self.claude_client = None
        
        try:
            self.openai_client = OpenAIClient()
            print("‚úÖ OpenAI Client –¥–æ—Å—Ç—É–ø–µ–Ω")
        except Exception as e:
            print(f"‚ö†Ô∏è OpenAI Client –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
            self.openai_client = None
        
        # Memory manager –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω
        self.memory_manager = None
        
        # –ö—ç—à –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞–º–ø–∞–Ω–∏–π
        self.active_campaigns: List[Campaign] = []
        self.last_cache_update = 0
        self.cache_ttl = 10  # 10 —Å–µ–∫—É–Ω–¥ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ—Ç–∫–ª–∏–∫–∞ –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è
        self.force_refresh = False  # –§–ª–∞–≥ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        
        print("ü§ñ Telegram Agent –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å Telegram"""
        try:
            await self.client.start(phone=self.phone)
            print(f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω –∫ Telegram –∫–∞–∫ {self.phone}")
            
            # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π
            self.client.add_event_handler(self.handle_new_message, events.NewMessage)
            
            # –ó–∞–≥—Ä—É–∑–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞–º–ø–∞–Ω–∏–π
            await self.refresh_campaigns_cache()
            
            return True
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Telegram: {e}")
            return False
    
    async def disconnect(self):
        """–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç Telegram"""
        if self.client.is_connected():
            await self.client.disconnect()
            print("üëã –û—Ç–∫–ª—é—á–µ–Ω –æ—Ç Telegram")
    
    def is_connected(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å Telegram"""
        return self.client.is_connected()
    
    async def refresh_campaigns_cache(self, force: bool = False):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞–º–ø–∞–Ω–∏–π"""
        current_time = time.time()
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ TTL –∫—ç—à–∞ –∏–ª–∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        if not force and not self.force_refresh and current_time - self.last_cache_update < self.cache_ttl:
            return
        
        try:
            db = SessionLocal()
            campaigns = db.query(Campaign).filter(Campaign.active == True).all()
            self.active_campaigns = campaigns
            self.last_cache_update = current_time
            self.force_refresh = False  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥
            
            print(f"üîÑ –ö—ç—à –∫–∞–º–ø–∞–Ω–∏–π –æ–±–Ω–æ–≤–ª–µ–Ω: {len(campaigns)} –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞–º–ø–∞–Ω–∏–π")
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–∞ –∫–∞–º–ø–∞–Ω–∏–π: {e}")
        finally:
            db.close()
    
    def force_campaigns_refresh(self):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ñ–ª–∞–≥–∞ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–∞"""
        self.force_refresh = True
        print("üîÑ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ –∫–∞–º–ø–∞–Ω–∏–π")
    
    async def handle_new_message(self, event):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            message: Message = event.message
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
            await self.refresh_campaigns_cache()
            
            # –ü–æ–∏—Å–∫ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –∫–∞–º–ø–∞–Ω–∏–π
            matching_campaigns = await self.find_matching_campaigns(message)
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–∂–¥–æ–π –ø–æ–¥—Ö–æ–¥—è—â–µ–π –∫–∞–º–ø–∞–Ω–∏–∏
            for campaign in matching_campaigns:
                await self.process_campaign_trigger(campaign, message)
                
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
    
    async def find_matching_campaigns(self, message: Message) -> List[Campaign]:
        """–ü–æ–∏—Å–∫ –∫–∞–º–ø–∞–Ω–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –æ—Ç—Ä–µ–∞–≥–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ"""
        matching_campaigns = []
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ ID —á–∞—Ç–∞
        chat_id = str(message.peer_id.channel_id if hasattr(message.peer_id, 'channel_id') 
                     else message.peer_id.chat_id if hasattr(message.peer_id, 'chat_id')
                     else message.peer_id.user_id)
        
        # –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
        message_text = message.text.lower() if message.text else ""
        
        for campaign in self.active_campaigns:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–∞—Ç–æ–≤
            if not self.is_chat_monitored(chat_id, campaign.telegram_chats):
                continue
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
            if not self.contains_keywords(message_text, campaign.keywords):
                continue
            
            matching_campaigns.append(campaign)
        
        return matching_campaigns
    
    def is_chat_monitored(self, chat_id: str, monitored_chats: List[str]) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞, –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç—Å—è –ª–∏ —á–∞—Ç –≤ –∫–∞–º–ø–∞–Ω–∏–∏"""
        return chat_id in monitored_chats or any(
            chat.startswith('@') and chat[1:] in chat_id for chat in monitored_chats
        )
    
    def contains_keywords(self, text: str, keywords: List[str]) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –≤ —Ç–µ–∫—Å—Ç–µ"""
        return any(keyword.lower() in text for keyword in keywords)
    
    async def process_campaign_trigger(self, campaign: Campaign, trigger_message: Message):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç—Ä–∏–≥–≥–µ—Ä–∞ –∫–∞–º–ø–∞–Ω–∏–∏"""
        start_time = time.time()
        
        try:
            # –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
            context_messages = await self.get_context_messages(
                trigger_message,
                campaign.context_messages_count
            )
            
            # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ Claude
            response = await self.generate_response(
                campaign,
                trigger_message,
                context_messages
            )
            
            # –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞
            await self.send_response(trigger_message, response)
            
            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
            processing_time = int((time.time() - start_time) * 1000)
            await self.log_activity(
                campaign,
                trigger_message,
                context_messages,
                response,
                "sent",
                processing_time=processing_time
            )
            
            print(f"‚úÖ –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –¥–ª—è –∫–∞–º–ø–∞–Ω–∏–∏ '{campaign.name}'")
            
        except Exception as e:
            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–∫–∏
            processing_time = int((time.time() - start_time) * 1000)
            await self.log_activity(
                campaign,
                trigger_message,
                [],
                "",
                "failed",
                error_message=str(e),
                processing_time=processing_time
            )
            
            print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–∞–º–ø–∞–Ω–∏–∏ '{campaign.name}': {e}")
    
    async def get_context_messages(self, trigger_message: Message, count: int) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
            messages = []
            async for message in self.client.iter_messages(
                trigger_message.peer_id,
                limit=count + 1,
                max_id=trigger_message.id
            ):
                if message.id != trigger_message.id:
                    messages.append({
                        "id": message.id,
                        "text": message.text or "",
                        "date": message.date.isoformat(),
                        "from_user": str(message.from_id) if message.from_id else "unknown"
                    })
            
            return messages[:count]  # –û–±—Ä–µ–∑–∞–µ–º –¥–æ –Ω—É–∂–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞: {e}")
            return []
    
    async def generate_response(
        self,
        campaign: Campaign,
        trigger_message: Message,
        context_messages: List[Dict]
    ) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ –≤—ã–±—Ä–∞–Ω–Ω—ã–π AI –ø—Ä–æ–≤–∞–π–¥–µ—Ä"""
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º AI –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞
        ai_provider = getattr(campaign, 'ai_provider', 'claude')
        
        try:
            if ai_provider == "openai" and self.openai_client:
                response = await self._generate_with_openai(campaign, trigger_message, context_messages)
            elif ai_provider == "claude" and self.claude_client:
                response = await self._generate_with_claude(campaign, trigger_message, context_messages)
            else:
                # Fallback –Ω–∞ –¥–æ—Å—Ç—É–ø–Ω—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä
                if self.openai_client:
                    print(f"‚ö†Ô∏è Fallback –Ω–∞ OpenAI (Claude –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)")
                    response = await self._generate_with_openai(campaign, trigger_message, context_messages)
                elif self.claude_client:
                    print(f"‚ö†Ô∏è Fallback –Ω–∞ Claude (OpenAI –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)")
                    response = await self._generate_with_claude(campaign, trigger_message, context_messages)
                else:
                    raise Exception("–ù–∏ –æ–¥–∏–Ω AI –ø—Ä–æ–≤–∞–π–¥–µ—Ä –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω")
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç—å Zep
            await self.memory_manager.add_interaction(
                session_id=f"campaign_{campaign.id}_chat_{trigger_message.peer_id}",
                message=trigger_message.text,
                response=response
            )
            
            return response
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞: {e}")
            return "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞."
    
    async def _generate_with_claude(
        self,
        campaign: Campaign,
        trigger_message: Message,
        context_messages: List[Dict]
    ) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ Claude"""
        
        # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞ –¥–ª—è Claude
        context_text = "\n".join([f"[{msg['date']}] {msg['text']}" for msg in context_messages])
        
        prompt = f"""
–°–∏—Å—Ç–µ–º–Ω–∞—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è: {campaign.system_instruction}

–ö–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π:
{context_text}

–°–æ–æ–±—â–µ–Ω–∏–µ-—Ç—Ä–∏–≥–≥–µ—Ä: {trigger_message.text}

–ü—Ä–∏–º–µ—Ä—ã –æ—Ç–≤–µ—Ç–æ–≤: {campaign.example_replies if campaign.example_replies else '–ù–µ—Ç –ø—Ä–∏–º–µ—Ä–æ–≤'}

–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π –æ—Ç–≤–µ—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏ —Å–∏—Å—Ç–µ–º–Ω–æ–π –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏.
"""
        
        return await self.claude_client.generate_response(
            prompt,
            campaign.claude_agent_id
        )
    
    async def _generate_with_openai(
        self,
        campaign: Campaign,
        trigger_message: Message,
        context_messages: List[Dict]
    ) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ OpenAI"""
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è OpenAI
        prompt = self.openai_client.format_telegram_context(
            system_instruction=campaign.system_instruction,
            context_messages=context_messages,
            trigger_message=trigger_message.text,
            example_replies=campaign.example_replies
        )
        
        # –ü–æ–ª—É—á–∞–µ–º –º–æ–¥–µ–ª—å OpenAI –∏–∑ –∫–∞–º–ø–∞–Ω–∏–∏
        openai_model = getattr(campaign, 'openai_model', 'gpt-4')
        
        return await self.openai_client.generate_response(
            prompt,
            model=openai_model
        )
    
    async def send_response(self, original_message: Message, response: str):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞ –≤ —á–∞—Ç"""
        try:
            await self.client.send_message(
                original_message.peer_id,
                response,
                reply_to=original_message.id
            )
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞: {e}")
            raise
    
    async def log_activity(
        self,
        campaign: Campaign,
        trigger_message: Message,
        context_messages: List[Dict],
        response: str,
        status: str,
        error_message: Optional[str] = None,
        processing_time: Optional[int] = None
    ):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∞–≥–µ–Ω—Ç–∞"""
        try:
            db = SessionLocal()
            
            # –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —á–∞—Ç–µ
            chat_title = "Unknown"
            try:
                entity = await self.client.get_entity(trigger_message.peer_id)
                if hasattr(entity, 'title'):
                    chat_title = entity.title
                elif hasattr(entity, 'username'):
                    chat_title = f"@{entity.username}"
            except:
                pass
            
            # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞
            trigger_keyword = "unknown"
            if trigger_message.text:
                message_text = trigger_message.text.lower()
                for keyword in campaign.keywords:
                    if keyword.lower() in message_text:
                        trigger_keyword = keyword
                        break
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ª–æ–≥–∞
            log_entry = ActivityLog(
                campaign_id=campaign.id,
                chat_id=str(trigger_message.peer_id),
                chat_title=chat_title,
                message_id=trigger_message.id,
                trigger_keyword=trigger_keyword,
                context_messages=context_messages,
                original_message=trigger_message.text or "",
                agent_response=response,
                status=status,
                error_message=error_message,
                processing_time_ms=processing_time
            )
            
            db.add(log_entry)
            db.commit()
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")
        finally:
            db.close()